堆：
	1.根节点的关键字既大于或等于左子树的关键字值，又大于或等于右子树的关键字值。
	2.为完全二叉树。

最大堆：
	父节点的值应该大于或等于子节点。

最小堆：
	父节点的值应该小于或等于子节点。


优先级队列：
在优先级队列中，低优先级的元素之前前面应该是高优先级的元素。如果两个元素具有相同的优先级，则根据它们在队列中的顺序是它们的出现顺序即可。
优先队列可以用堆或其他方法实现，例如无序数组。
优先队列是一个抽象概念。


哈希表：
使用散列函数来计算一个值在数组或桶（buckets）中或槽（slots）中对应的索引，可用该索引找到所需的值。
理想情况：每个key对应一个唯一的bucket
实际情况：散列函数可能为多个key生成相同索引，需要通过某种方式解决哈希冲突。


字典树/前缀树：
优点：最大限度地减少无谓的字符串比较。
核心思想：空间换时间，利用字符串的公共前缀来降低查询时间的开销来提高效率。
基本性质：
	1.根节点不包含字符，除根节点外每一个节点都只包含一个字符。
	2.从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
	3.每个节点的所有子节点包含的字符都不相同。

字典树它并不用等待你完全输入完毕后才查询。

二叉搜索树：
    若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
    若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
    任意节点的左、右子树也分别为二叉查找树；

二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O ( log ⁡ n ) 
二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。 

在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 O ( log ⁡ n )，增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。
balanceFactor: this.leftHeight - this.rightHeight
[详细图文——AVL树](https://blog.csdn.net/qq_25343557/article/details/89110319)


算法：
计数排序：
首先创建一个buckets数组用于存放比currentValue出现小的频率，
这样可以得到一个由0开始递增的buckets数组
PS：在此过程中，假如有为0的会先是空白，然后填充上一次的频率。
此时buckets数组存放的即为排序完的下标。对应索引为value- minValue

