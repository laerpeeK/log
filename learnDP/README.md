摘自：《JavaScript设计模式与开发实践》
仅做个人学习使用，请支持正版。

单例模式：
定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
例子：线程池、全局缓存、浏览器中window对象等

策略模式：
定义：定义一系列算法，把它们一个个封装起来，并且使他们可以相互替换。
一个基于策略模式的程序至少由两部分构成：策略类与环境类。
策略类：封装了具体的算法，并负责具体的计算过程。
环境类：接受客户的请求，随后把请求委托给某一个策略类。

代理模式：
定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
保护代理：用于控制不同权限的对象对目标对象的访问。
虚拟代理：
	应用：图片预加载、合并HTTP请求、惰性加载
好处：1.用户可以放心地请求代理，他只关心是否能得到想要的结果。2. 在任何使用本体的地方都可以替换成使用代理
缓存代理：可以为一些开销大的运算结果提供暂时的存储
	应用：分页
防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近
远程代理：为一个对象在不同的地址空间提供局部代表。
智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。
写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。

迭代器模式：
定义：提供一种方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。
内部迭代器：函数内部已经定义好迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。
外部迭代器：必须显式地请求迭代下一个元素。
迭代前提：被迭代的聚合对象拥有length属性，且可以用下标访问。

发布订阅模式：
定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，
所有依赖它的对象都将得到通知。
应用：异步编程中替代传递回调函数，使用发布订阅模式，我们就
无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。
实现步骤：
	1.首先指定谁充当发布者。
	2.然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者。
	3.最后发布消息时，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数。
	4.可以往回调函数里添加一些参数。
推模型：在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。
拉模型：发布者仅仅通知订阅者事件已经发生，此外发布者需要提供一些公开的接口供订阅者来主动拉取数据。

命令模式：
命令：指的是一个执行特定事情的指令。
好处：
	1.解开请求调用者和请求接收者之间的耦合关系。
	2.command对象拥有更长的生命周期。


组合模式：
定义：用小的子对象来构建更大的对象，而这些小的对象本身又由更小的“孙对象”组成
好处：
	1.将对象组合成数形结构，以表示“部分-整体”的层次结构。
	2.通过对象的多态性表现，使得用户对单个对象和组合对象作用具有一致性。
适用情况：
	1.表示对象的部分-整体层次结构。
	2.客户希望统一对待树中的所有对象。
缺点：可能造成太多的对象，或是难以理解的对象。


模板方法模式：
定义：抽象父类和具体实现子类。
抽象父类封装子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。
子类：继承抽象类，可以选择重写父类的方法。
抽象类不能被实例化。

亨元模式：
一种用于性能优化的模式，核心是运用共享技术来有效支持大量细颗粒度的对象。
要求将对象的属性划分为内部和外部。目标是尽量减少共享对象的数量。
如何划分内部和外部状态/属性
1.内部状态存储在对象内部
2.内部状态可以被一些对象共享
3.内部状态独立于具体的场景，通常不会改变
4.外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。
通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象。
优化：
1.只有当某种共享对象被真正需要时，它才从工厂中被创建出来。
2.可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子
和共享对象联系起来。

职责链模式：
定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
优点：
	1.只需要把请求传递给第一个节点即可。
	2.可以手动指定起始节点。
缺点：
	1.使程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分的节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链带来的性能损耗。
	
中介者模式：
作用：解除对象与对象之间的紧耦合关系。
所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象
发生改变时，只需要通知中介者对象即可。
缺点：因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常时巨大的，增加维护难度。
		中介者对象要占一部分内存。
使用条件：如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。

装饰者模式：
可以动态地给某个对象添加一些额外地职责，而不会影响从这个类中派生的其他对象。
在JS中：不直接改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口。当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。
