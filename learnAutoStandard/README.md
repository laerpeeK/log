## 此文件夹用于学习京东凹凸实验室代码规范

#### Auto.io：[京东凹凸实验室代码规范][https://guide.aotu.io/docs/]

#### JavaScript规范

##### 类型：

1. 原始类型：存储原始类型直接作用值本身

2. 复杂类型：访问复杂类型作用于值的引用

3. 对所有引用都使用const, 这样做可以确保你无法重新分配引用，以避免错误与难以理解的代码

4. 如果引用是可变动的，使用let代替var



##### 对象：

1. 请使用对象字面量创建对象

2. 别使用保留字作为对象的键值，这样在IE8不会运行

3. 当使用动态属性名创建对象时，请使用对象计算属性名来进行创建，这样做可以让你在一个地方定义所有的对象属性

4. 请使用对象方法的简写方式

5. 请使用对象属性值的简写方式, 这样更简短且描述更清楚

6. 将简写的对象属性分组后统一放到对象声明的开头

7. 只对非法标识符的属性使用引号，因为通常来说我们认为这样主观上会更容易阅读，这样会带来代码高亮上的提升，同时也更容易被JS主流引擎优化。非法标识符： 标识符组成不仅是字母，数字，下划线
8. 不要直接使用Object.prototype的方法,因为这些方法可能会被对象自身的同名属性覆盖
9. 优先使用对象运算符...来做对象浅拷贝而不是使用Object.assign，使用对象剩余操作符来获得一个包含确定的剩余属性的新对象



##### 字符串：

1. 字符串统一使用单引号的形式
2. 字符串太长时，请不要使用字符串连接符换行\，而是使用+
3. 程序化生成字符串时，请使用模板字符串
4. 不要对字符串使用eval()，会导致太多漏洞
5. 不要在字符串中使用不必要的转义字符



##### 数组：

1. 请使用对象字面量值创建数组
2. 向数组中添加元素时，请使用push方法
3. 使用展开运算符...复制数组
4. 把一个可迭代的对象转换成数组时，使用展开运算符...而不是Array.from，可以应用 for..of 的对象被称为 可迭代的
5. 使用Array.from来将一个类数组对象转换为对象，有索引属性和 length 属性的对象被称为 类数组对象
6. 遍历迭代器进行映射时使用Array.from代替扩展运算符...，因为这可以避免创建中间数组
7. 使用数组的map等方法时，请使用return声明，如果是单一声明语句的情况，可省略return
8. 如果一个数组有多行则要在数组的开括号后和闭括号前使用新行
9. 解构赋值,解构可以避免创建属性的临时引用
10. 当需要使用数组的多个值时,请同样使用解构赋值
11. 函数需要回传多个值时，请使用对象的解构，而不是数组的解构，因为这样做可以非破坏地随时增加或者改变属性顺序，如果是数组解构，那么在调用时就需要考虑数据的顺序



##### 模块：

1. 不要使用Function构造函数创建函数，此方式创建函数和对字符串使用 eval() 一样会产生漏洞
2. 在函数签名中使用空格
3. 使用具名函数表达式而非函数声明，函数声明会导致函数声明被提升，这意味着很容易在文件中定义此函数之前引用它，不利于可读性和可维护性。如果你发现函数定义既庞大又复杂以至于不能理解文件的其他部分，或许你应该将它拆分成模块！别忘记要显式命名表达式，而不用管名字是否是从包含的变量（通常出现在现代浏览器中或者使用 Babel 编译器的时候）中推断的。这样会消除错误调用堆栈中的任何假设。 (讨论)
4. 用圆括号包裹自执行匿名函数，一个立即执行匿名函数表达式是一个单一的单元，将其及其调用括号包装在括号中，能够清楚地表达这一点。注意，在到处都是模块的世界中几乎不需要 IIFE。
5. 不要在非函数代码块(if, while等)中声明函数
6. 不要将参数命名为arguments, 会导致该参数的优先级高于每个函数作用域内原先存在的arguments对象
7. 不要使用arguments, 使用剩余运算符...arguments只是一个类数组， 而...是一个真正的数组
8. 使用参数默认值语法而不是修改函数参数
9. 避免参数默认值的副作用
10. 将参数默认值放在最后
11. 不要更改参数，操作作为参数传入的对象可能在原始调用中造成意想不到的变量副作用
12. 不要给参数重新赋值，参数重新赋值可能会导致无法预期的行为，尤其是当操作 arguments 对象时，也可能导致优化问题，尤其是在 V8 引擎中
13. 调用可变参数函数时建议使用展开运算符 ....，显然你无需使用上下文，很难结合 new 和 apply



#### 箭头函数

1. 当你必须使用函数表达式（传递匿名函数）时，使用箭头函数标记，它将创建在 this 上下文中执行的函数版本，通常是您想要的，并且语法更简洁，如果您有一个相当复杂的函数，则可以将该逻辑移到其自己的命名函数表达式中
2. 如果函数体只包含一条没有副作用的返回表达式的语句，可以省略花括号并使用隐式的 return， 否则保留花括号并使用 return 语句
3. 一旦表达式跨多行，使用圆括号以便更好阅读
4. 函数如果只接收一个参数并且没使用花括号，则省略圆括号，否则为了清晰明确，则使用圆括号包裹参数，注意：总是使用圆括号也是可以接受的
5. 使用class, 避免直接操作prototype
6. 使用extends来实现继承，这是一个不会破坏instanceof的内建实现原型式继承的方式
7. 如果未声明构造函数，则类会有一个默认的构造函数，没必要用空的构造函数或者将其委托给父类
8. 避免类成员重复，因为重复的类成员声明会默认使用最后声明的，通常会导致bug



#### ES6：

1. 模块：使用标准的ES6模块语法import和export
2. 迭代器：不要使用iterators， 建议使用JS更高优先级的函数代替for-in或for-of循环，除非迫不得已
3. 生成器：现阶段请不要使用生成器generator，因为不能很好地翻译成ES5代码
4. 对象属性：使用.来访问属性
5. 对象属性：当访问的属性是变量时使用[]
6. 变量声明：声明变量时，请使用const, let关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能和现有变量冲突，另外，也很难明确该变量的作用域是什么。建议使用const来声明变量，我们需要避免全局空间的污染
7. 变量不要进行链式赋值，变量链式赋值会创建隐藏的全局变量
8. 不允许出现未被使用的变量，声明但未被使用的变量通常是不完全重构犯下的错误，这种变量在代码里浪费空间，并会给读者构成困扰
9. Hoisting: var存在变量提升的情况，即var声明会被提升至该作用域的顶部,但是他们的赋值并不会，而const和let被赋予了Temporal Dead Zones
10. 匿名函数的变量名会提升，但函数内容不会
11. 命名的函数表达式的变量名会被提升，但函数名和函数内容并不会
12. 比较运算符&相等：使用===和 !== 而非 == 和 !=
13. 条件声明例如if会用Boolean这个抽象方法将表达式转成布尔值并遵从如下规则：

| origin       | boolean                 |
| ------------ | ----------------------- |
| Object       | true                    |
| []           | true                    |
| Undefined    | false                   |
| Null         | false                   |
| Boolean      | boolean                 |
| +0, -0 , NaN | false                   |
| other number | true                    |
| string       | ''为false, 其他未为true |
|              |                         |

14. 不使用分号，除例外情况
15. 标准特性：为了代码的可移植性和兼容性，我们应最大化的使用标准方法
16. 不使用eval () , with () {}
17. 不修改内置对象的原型

