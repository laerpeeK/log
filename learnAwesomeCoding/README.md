题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。
例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

回溯法：
记录一个字符（temp），用于存储当前需要进入排列的字符
记录一个字符串（current），用于记录当前已经排列好的字符
记录一个队列（queue），用于存储还未被排列的字符


    每次排列将temp添加到current
    如果queue为空，则本次排列完成，将curret加入到结果数组中，结束递归
    如果queue不为空，说明还有未排列的字符
    递归排列queue中剩余的字符
    为了不影响后续排列，每次递归完成，将当前递归的字符temp加回队列


题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。


直接将归并排序进行改进，把数据分成N个小数组。

合并数组 left - mid , mid+1 - right，合并时， 若array[leftIndex] > array[rightIndex] ,则比右边 rightIndex-mid个数大

count += rightIndex-mid

注意和归并排序的区别： 归并排序是合并数组数从小数开始，而本题是从大数开始。



题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

借助图形思考，将复杂的矩阵拆解成若干个圈，循环打印矩阵，每次打印其中一个圈

设起点坐标为(start,start)，矩阵的行数为rows，矩阵的列数为columns
[1,2,3]
[4,5,6]
[7,8,9]
循环结束条件为 rows>start*2 并且 columns>start*2

将打印一圈拆解为四部，

    第一步：从左到右打印一行
    第二步：从上到下打印一列
    第三步：从右到左打印一行
    第四步：从下到上打印一列

最后一圈很有可能出现几种异常情况,打印矩阵最里面一圈可能只需三步、两步、甚至一步

所以在每一行打印时要做好条件判断:

能走到最后一圈，从左到右必定会打印

结束行号大于开始行号，需要从上到下打印

结束列号大于开始列号，需要从右到左打印

结束行号大于开始行号+1，需要从下到上打印



二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，对于树中每个节点：

    若其左子树存在，则其左子树中每个节点的值都不大于该节点值；
    若其右子树存在，则其右子树中每个节点的值都不小于该节点值。

